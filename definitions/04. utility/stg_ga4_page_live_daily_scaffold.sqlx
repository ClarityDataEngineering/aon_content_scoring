config {
    type: 'table',
    schema: project_config.OUTPUT_STAGING_DATASET, 
    description: 'Daily scaffold for each page: first_seen_date, days/weeks/months live, HTTP status, and page live status flags. Centralises logic for determining when pages are live and accessible.',
    bigquery: {
        labels: {
          table_name: "content_scoring_stg_pages_time_live_scaffold"
        }
    }
}

-- Get all insight pages and the first date that it was seen
with first_insight_page_date as (
    select
        ${helpers.sanitiseURL('page_location_clean')} as page_location_clean
        , min(event_date_dt) as first_seen_date
    from 
        ${ref('final_ga4_pages')}
    where
       regexp_contains(page_location_clean, r'${project_config.PAGES_TO_INCLUDE_RX}')
    group by 
        page_location_clean
)

-- Generate a daily calendar covering from the input start to the current date  
, calendar as (
    ${helpers.generateCalendar(project_config.START_DATE)}
)

-- Get the HTTP status of thought leadership pages 
, http_status_code as (
    select
        date(checked_at) as event_date_dt
        , url as page_location_clean
        , http_status
    from 
        ${ref('thought_leadership_http_status_log')}
)

-- Get pages that have ever been HTTP status checked
, pages_with_status_checks as (
    select distinct
        page_location_clean
        , true as has_been_status_checked
    from 
        http_status_code
)

-- Cross join every insights page to every date, then filter to valid periods (i.e. not before a page was seen live)
, page_date_matrix as (
    select
        d.event_date_dt
        , p.page_location_clean
        , p.first_seen_date
        , coalesce(psc.has_been_status_checked, false) as has_been_status_checked
    from 
        first_insight_page_date p
    cross join 
        calendar d
    left join 
        pages_with_status_checks psc on p.page_location_clean = psc.page_location_clean
    where 
        d.event_date_dt >= p.first_seen_date
)

-- Assigns a ranking to each row to get the most recent status by date/page
, status_backfill as (
    select
        pdm.event_date_dt
        , pdm.page_location_clean
        , pdm.first_seen_date
        , pdm.has_been_status_checked
        , hsc.http_status
        , row_number() over (
            partition by pdm.page_location_clean, pdm.event_date_dt
            order by hsc.event_date_dt desc
        ) as rn
    from page_date_matrix pdm
    left join http_status_code hsc
      on pdm.page_location_clean = hsc.page_location_clean
      and hsc.event_date_dt <= pdm.event_date_dt
)

-- Add window functions to calculate key page lifecycle dates
, with_lifecycle_dates as (
    select
        event_date_dt
        , page_location_clean
        , first_seen_date
        , has_been_status_checked
        , http_status
        , date_diff(event_date_dt, first_seen_date, DAY) + 1 as days_live
        -- Calculate weeks/months live based on 7/30 day periods from first_seen_date
        , div(date_diff(event_date_dt, first_seen_date, DAY), 7) + 1 as weeks_live
        , div(date_diff(event_date_dt, first_seen_date, DAY), 30) + 1 as months_live
        -- Calculate key lifecycle dates per page
        , max(case when http_status = 200 then event_date_dt end) over (partition by page_location_clean) as last_200_date
        , min(case when http_status != 200 and http_status is not null then event_date_dt end) over (partition by page_location_clean) as first_non_200_date
        , min(event_date_dt) over (partition by page_location_clean) as first_tracked_date
        , max(event_date_dt) over (partition by page_location_clean) as last_tracked_date
    from 
        status_backfill
    where
        rn = 1
)

select
    event_date_dt
    , page_location_clean
    , first_seen_date
    , has_been_status_checked
    , http_status
    , days_live
    , weeks_live
    , months_live
    , last_200_date
    , first_non_200_date
    , first_tracked_date
    , last_tracked_date
    -- Determine if page is considered "live" for this date
    , case 
        when last_200_date is null then false -- Never had a 200 status
        when first_non_200_date is not null and event_date_dt >= first_non_200_date then false -- Page went down
        when event_date_dt < first_seen_date then false -- Before page went live (shouldn't happen due to filter, but safety check)
        else true
    end as is_page_live
    -- Additional flags
    , case when http_status = 200 then true else false end as is_200_today
    , case when http_status != 200 and http_status is not null then true else false end as is_error_today
    , case when last_200_date is not null then true else false end as ever_had_200_status
    , case when first_non_200_date is not null and event_date_dt >= first_non_200_date then true else false end as is_post_failure
    , case when event_date_dt = first_seen_date then true else false end as is_first_seen_date
    -- Flag for pages that need HTTP status checking (new pages)
    , case when not has_been_status_checked then true else false end as needs_status_check
    -- Weekly aggregation helpers
    , date_trunc(event_date_dt, WEEK(MONDAY)) as week_start_date
    , date_trunc(event_date_dt, MONTH) as month_start_date
from 
    with_lifecycle_dates